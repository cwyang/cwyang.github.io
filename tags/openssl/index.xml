<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>openssl on A Tale That Wasn&#39;t Left</title>
    <link>https://cwyang.github.io/tags/openssl/</link>
    <description>Recent content in openssl on A Tale That Wasn&#39;t Left</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Feb 2023 20:00:00 +0000</lastBuildDate>
    <atom:link href="https://cwyang.github.io/tags/openssl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HAProxy, 그리고 OpenSSL3 성능</title>
      <link>https://cwyang.github.io/2023/02/03/slow-openssl-3.0.html/</link>
      <pubDate>Fri, 03 Feb 2023 20:00:00 +0000</pubDate>
      <guid>https://cwyang.github.io/2023/02/03/slow-openssl-3.0.html/</guid>
      <description>OpenSSL 3.0의 큰 설계방향은 개발의 편의성을 위해서 모듈화/추상화를 만들어 넣은 건데, 반대급부로 성능이 많이 떨어졌습니다. 모듈이 복잡해지면 공유자원 사용을 위한 락이 많이 사용되는 경향이 있기 때문에, 스레드(코어)가 많아질수록 CPU 락 경합때문에 발생하는 성능 저하 현상이 문제가 됩니다.</description>
    </item>
    <item>
      <title>OpenSSL 3.0</title>
      <link>https://cwyang.github.io/2019/12/19/openssl-3.0.html/</link>
      <pubDate>Thu, 19 Dec 2019 11:33:00 +0000</pubDate>
      <guid>https://cwyang.github.io/2019/12/19/openssl-3.0.html/</guid>
      <description>벌써 연말이다. 2020년에는 OpenSSL 3.0이 발표 예정이다. OpenSSL 1.1.1 작업을 한 지도 얼마 안되었는데&amp;hellip;</description>
    </item>
    <item>
      <title>SSL_read()와 read()는 같은가요?</title>
      <link>https://cwyang.github.io/2009/10/21/SSL-read-vs-read.html/</link>
      <pubDate>Wed, 21 Oct 2009 14:48:00 +0000</pubDate>
      <guid>https://cwyang.github.io/2009/10/21/SSL-read-vs-read.html/</guid>
      <description>네트워크 프로그래밍시에 SSL 연결과의 자료전송도 필요하게 되면 SSL_read()와 SSL_write()를 써야하기 마련이다. 많은 경우 SSL연결 뿐만이 아닌 일반 전송도 필요하므로, 프로그래머는 대개 아래와 같이 연결 종류에 무관한 wrapping API를 만들어서 진행하는데, 이 경우 SSL_read()와 read()의 차이점을 알아야한다.</description>
    </item>
  </channel>
</rss>
