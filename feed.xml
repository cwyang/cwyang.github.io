<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>양철웅의 DX 이야기</title>
    <description>short essays on DX, cyber security, and cloud
</description>
    <link>http://cwyang.github.io/</link>
    <atom:link href="http://cwyang.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 26 Mar 2023 09:47:08 +0900</pubDate>
    <lastBuildDate>Sun, 26 Mar 2023 09:47:08 +0900</lastBuildDate>
    <generator>Jekyll v3.9.3</generator>
    
      <item>
        <title>Linux Settings in 2023</title>
        <description>&lt;p&gt;잠시 사용하던 윈도우에서 다시 리눅스로 돌아가고자 한다.
랩탑에 설치하는 것은 처음이다. 윈도우와 최대한 유사하게 꾸며보기로 한다.&lt;/p&gt;

&lt;h3 id=&quot;확인할-것들--개선필요사항&quot;&gt;확인할 것들 / 개선필요사항&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BIOS sleep state: linux(s3) sleep vs windows modern sleep
    &lt;ul&gt;
      &lt;li&gt;modern standby가 더 신속하지만 power를 많이 먹는다고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기본-환경&quot;&gt;기본 환경&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Thinkpad X1 Carbon Gen9&lt;/li&gt;
  &lt;li&gt;Mint Linux 21.1 (2022년 12월 출시)&lt;/li&gt;
  &lt;li&gt;파티션: base(60G), swap(16G), home(100G)&lt;/li&gt;
  &lt;li&gt;부트로더: on hdd. windows bootmgr와 별도로 구성&lt;/li&gt;
  &lt;li&gt;한글: fcitx (기본)
    &lt;ul&gt;
      &lt;li&gt;한영전환: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl+Space&lt;/code&gt;(기본), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift+Space&lt;/code&gt; (추가)&lt;/li&gt;
      &lt;li&gt;사용하다보면 힌트윈도우가 떠서 거슬릴때가 있는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl+Alt+P&lt;/code&gt;로 비활성화 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블루투스, 사운드, 웹캠 기본 정상작동&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;핫키설정&quot;&gt;핫키설정&lt;/h3&gt;
&lt;p&gt;Setting » Keyboard » Shortcut 에서 지정한다. 윈도우와 유사하게 설정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Run Dialog: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+R&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Home Folder: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+E&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Web Browser: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+C&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Terminal: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Setting: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+I&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Lock Device: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+L&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Push Tile: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Super+DIR&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Move Tile to Other Monitor: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shft+Super+DIR&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Screenshot to Clipboard: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift+Super+S&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ACPI성능프로파일: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fn+L&lt;/code&gt; (low) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fn+M&lt;/code&gt; (mid), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fn+H&lt;/code&gt; (high perf)
    &lt;ul&gt;
      &lt;li&gt;확인: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /sys/firmware/acpi/platform_profile&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치-앱&quot;&gt;설치 앱&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Google Chrome&lt;/li&gt;
  &lt;li&gt;Virtual Box&lt;/li&gt;
  &lt;li&gt;VS Code&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;웹앱&quot;&gt;웹앱&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;특정 웹 브라우저를 앱과 같이 등록할 수가 있다. 웹 메신저등에 활용가능하다.
실행중이 아니면 알림을 못받는 문제, 알림뱃지등이 없는 한계가 있지만 아쉬운대로 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webapp-manager&lt;/code&gt; 등록후 taskbar고정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;가상환경&quot;&gt;가상환경&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;default vagrant 가 vbox 7.x을 지원하지 않아 vbox 6.0을 설치하여 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;네트워크&quot;&gt;네트워크&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;태스크바에 네트워크 추가
    &lt;ul&gt;
      &lt;li&gt;Setting » Startup Application » Add Network&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VPN
    &lt;ul&gt;
      &lt;li&gt;openconnect vpn을 사용한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt install network-manager-openconnect network-manager-openconnect-gnome&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;설치 이후 Setting » Network » Add VPN&lt;/li&gt;
      &lt;li&gt;vpn typ 설정 후 게이트웨이를 지정&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resolvectl --status&lt;/code&gt;로 vpn0에서 DNS 설정이 되어 있는지 확인한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프린터&quot;&gt;프린터&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Sindoh D400 linux driver
    &lt;ul&gt;
      &lt;li&gt;generic PCL6&lt;/li&gt;
      &lt;li&gt;https://hamonikr.org/board_practice/4537#comment_73416&lt;/li&gt;
      &lt;li&gt;https://acehyuk.tistory.com/351&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 26 Mar 2023 09:24:00 +0900</pubDate>
        <link>http://cwyang.github.io/2023/03/26/linux-settings.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2023/03/26/linux-settings.html</guid>
        
        <category>linux</category>
        
        <category>settings</category>
        
        <category>mint</category>
        
        <category>ubuntu</category>
        
        <category>thinkpad</category>
        
        
      </item>
    
      <item>
        <title>Azure VNET 라우팅</title>
        <description>&lt;p&gt;Azure의 VNET(Virtual Network)은 클라우드상의 네트워크 환경이다.
AWS의 VPC (Virtual Private Cloud)에 대응한다.
VNET에 할당된 주소범위(CIDR)를 구분하여 서브넷을 만들고, 서브넷간의 라우팅이 가능하다.
VNET은 독립된 네트워크인데 주소범위가 겹치지 않는다면 여러 VNET을 연결(peering)하여 구성이 가능하다.
이러면 VPC사이에서도 라우팅이 가능하다.&lt;/p&gt;

&lt;p&gt;라우팅 테이블은 서브넷마다 부여된다.
서브넷이란 원래 L2도메인, 즉 같은 네트워크상에서는 라우팅이 필요없이 목적지로 연결되는 의미인데
클라우드에서는 그렇지 않으며 단순히 VNET을 세분화한 네트워크 영역이다.
L2 도메인과 유사하게 동작하기 위해서 라우팅 테이블에
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서브넷 CIDR --&amp;gt; VNET&lt;/code&gt; 이라는 라우팅을 넣어야 한다.
편의를 위해 라우팅 테이블 생성시에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VPC CIDR --&amp;gt; VNET&lt;/code&gt; 항목이 기본적으로 등록된다.&lt;/p&gt;

&lt;p&gt;클라우드 네트워크 구현에 따라 서브넷이 L2도메인일 수도 있겠으나,
만약 라우팅 엔트리가 필요없이 서브넷간의 통신이 된다면
해당 클라우드의 네트워크가 SDN이 아닌 종래의 네트워크 구조에 기반하기 때문일 것이다.
복잡하고 큰 네트워크를 구성하기 위해서는 SDN구성이 좋고,
SDN구성에서는 서버들이 L2가 아닌 오버레이 L3로 연결되어있다.&lt;/p&gt;

&lt;p&gt;Azure 의 라우팅 목적지 타입으로는
(1) 로컬 VNET안의 서버로 보내기 위한 &lt;em&gt;VNET&lt;/em&gt;
(2) 인터넷 영역, 즉 인터넷 게이트웨이로 보내기 위한 &lt;em&gt;Internet&lt;/em&gt;
(3) 통신을 차단하기 위한 &lt;em&gt;Drop&lt;/em&gt;
(4) 연결된 다른 VNET으로 보내기 위한 &lt;em&gt;VNET Peering&lt;/em&gt;
(5) 연결된 다른 네트워크 (BGP나 VPN)로 보내기 위한 &lt;em&gt;VNET Gateway&lt;/em&gt;
(6) 허용된 특정 클라우드 서비스로 보내기 위한 &lt;em&gt;VNETServiceEndpoint&lt;/em&gt; 가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/azure-routing-example.png&quot; alt=&quot;Azure 라우팅 구성예&amp;lt;br&amp;gt;https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-udr-overview&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Azure는 사용자가 서브넷 라우팅을 생성하는 기능을 제공하는데 이를 UDR (User-Defined Routing) 이라고 한다.
정적static 라우팅, 커스텀 라우팅 모두 동일한 의미이다.
UDR에서는 침입탐지 시스템 등의 보안장비를 연동하기 위한 &lt;em&gt;Virtual Appliance&lt;/em&gt; 라우팅 목적지를 제공한다.&lt;/p&gt;

&lt;p&gt;등록된 서브넷 라우팅 엔트리에 대해 &lt;em&gt;Longest Prefix Match&lt;/em&gt;를 이용하여 라우팅을 결정한다.
주소매칭이 동일한 경우 (1) UDR (2) BGP (3) 시스템라우팅 순서로 우선한다.
다만 BGP라우트는 VNET, VNET Peering, VNETServiceEndpoint보다 우선순위가 낮다.&lt;/p&gt;

</description>
        <pubDate>Wed, 08 Feb 2023 20:00:00 +0900</pubDate>
        <link>http://cwyang.github.io/2023/02/08/Azure-VNET-routing.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2023/02/08/Azure-VNET-routing.html</guid>
        
        <category>CloudNetwork</category>
        
        <category>Azure</category>
        
        <category>VNET</category>
        
        <category>Subnet</category>
        
        <category>UDR</category>
        
        <category>VPC</category>
        
        <category>L2-domain</category>
        
        
      </item>
    
      <item>
        <title>ChatGPT-3가 설명하는 ChatGPT-3</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/cwyang-q.jpg&quot; alt=&quot;&quot; style=&quot;float: left&quot; /&gt;
Introduce &lt;a href=&quot;https://en.wikipedia.org/wiki/ChatGPT&quot;&gt;ChatGPT-3&lt;/a&gt; in style of blog writing.&lt;/p&gt;
&lt;p /&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/chatgpt-a.jpg&quot; alt=&quot;&quot; style=&quot;float: left&quot; /&gt;
Hello everyone! Today, we’ll be talking about the latest language model from OpenAI, ChatGPT-3. As the third iteration of the original GPT (Generative Pretrained Transformer) architecture, ChatGPT-3 has taken the world of NLP (Natural Language Processing) by storm.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/chatgpt3.jpg&quot; alt=&quot;ChatGPT-3, the game changer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This state-of-the-art model has been trained on a massive amount of diverse internet text, allowing it to generate human-like text with remarkable accuracy. From answering questions to translating languages, summarizing long texts, and performing other language-related tasks, ChatGPT-3 has shown unparalleled proficiency in its field.&lt;/p&gt;

&lt;p&gt;With its cutting-edge capabilities, ChatGPT-3 has set new standards in the NLP community and has been making waves in both academic and commercial applications. Whether you’re a researcher, a business owner, or just someone who’s curious about AI and NLP, ChatGPT-3 is a name that you should definitely keep an eye on.&lt;/p&gt;

&lt;p&gt;So, without further ado, let’s dive into the world of ChatGPT-3 and see what makes this model truly special.&lt;/p&gt;
&lt;p /&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/cwyang-q.jpg&quot; alt=&quot;&quot; style=&quot;float: left&quot; /&gt;
Translate the answer into Korean&lt;/p&gt;
&lt;p /&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/chatgpt-a.jpg&quot; alt=&quot;&quot; style=&quot;float: left&quot; /&gt;
안녕하세요! 오늘은 OpenAI에서 개발한 최신 언어 모델, &lt;a href=&quot;https://ko.wikipedia.org/wiki/ChatGPT&quot;&gt;ChatGPT-3&lt;/a&gt;에 대해 이야기해볼께요.
GPT (Generative Pretrained Transformer) 구조의 세 번째 버전인
ChatGPT-3은 NLP (Natural Language Processing) 세계를 휩쓸었습니다.&lt;/p&gt;

&lt;p&gt;이 고급 언어 모델은 다양한 인터넷 텍스트로 교육되었기 때문에,
놀랍도록 정확하게 인간처럼 텍스트를 생성합니다.
질문에 답하기, 언어 번역, 긴 텍스트 요약, 기타 언어 관련 작업까지,
ChatGPT-3은 자신의 분야에서 대단한 전문성을 보여주고 있습니다.&lt;/p&gt;

&lt;p&gt;최첨단 기능들로, ChatGPT-3은 NLP 커뮤니티에서 새로운 표준을 설정하였으며,
학술적인 뿐만 아니라 상업적인 응용도에서도 큰 파장을 일으키고 있습니다.
연구원, 사업가, 또는 AI와 NLP에 관심이 있는 사람이라면,
ChatGPT-3은 확실히 주의깊게 지켜봐야합니다.&lt;/p&gt;

&lt;p&gt;자, 더 망설이지 마시고, ChatGPT-3의 세계로 함께 들어갑시다.
그리고 이 모델이 가지는 진정하게 특별한 점이 무엇인지 알아보아요.&lt;/p&gt;
&lt;p /&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/cwyang-q.jpg&quot; alt=&quot;&quot; style=&quot;float: left&quot; /&gt;
Show me 10 hashtags that describes this article best&lt;/p&gt;
&lt;p /&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/chatgpt-a.jpg&quot; alt=&quot;&quot; style=&quot;float: left&quot; /&gt;
#ChatGPT3 #NLP #ArtificialIntelligence #CuttingEdgeTechnology #Research
#Business #AI #MachineLearning #Innovation #TechnologyTrends&lt;/p&gt;
&lt;p /&gt;

&lt;hr /&gt;

&lt;p&gt;ChatGPT3에게 세가지 질문을 하고, 결과를 약간 손 보아 올립니다.&lt;/p&gt;

&lt;p&gt;실사용이 가능한 대화형 인터페이스.
스마트폰 이후 또 하나의 기술 변곡점이 되지 않을까 생각합니다.&lt;/p&gt;

</description>
        <pubDate>Tue, 07 Feb 2023 20:00:00 +0900</pubDate>
        <link>http://cwyang.github.io/2023/02/07/what-is-chatgpt3.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2023/02/07/what-is-chatgpt3.html</guid>
        
        <category>ChatGPT3</category>
        
        <category>NLP</category>
        
        <category>ArtificialIntelligence</category>
        
        <category>CuttingEdgeTechnology</category>
        
        <category>Research</category>
        
        <category>Business</category>
        
        <category>AI</category>
        
        <category>MachineLearning</category>
        
        <category>Innovation</category>
        
        <category>TechnologyTrends</category>
        
        
      </item>
    
      <item>
        <title>HAProxy, 그리고 OpenSSL3 성능</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.haproxy.com/blog/announcing-haproxy-2-7/&quot;&gt;2022년 12월 HAProxy 2.7이 나왔습니다.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여러 개선중에 최대 스레드 지원이 기존 64개에서 4096개로 늘어난 것이 눈에 띕니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;However, due to the fast, atomic operations involved at many places, HAProxy was previously limited to 64 threads, and therefore 64 CPU cores, on 64-bit machines. This limit is now raised to 4096 threads by the introduction of thread groups.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사실 HA-Proxy는 이미 성능이 충분히 좋아서 최대 스레드를 저렇게 늘릴 까닭은 별로 없습니다… SSL 처리를 위해서가 아니라면요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/OpenSSL_logo.png&quot; alt=&quot;OpenSSL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문제는 HAProxy가 사용하고 있는 OpenSSL 3.0이 그렇게 성능이 좋지가 않다는 겁니다.
OpenSSL 3.0의 큰 설계방향은 개발의 편의성을 위해서 모듈화/추상화를 만들어 넣은 건데, 반대급부로 성능이 많이 떨어졌습니다.
모듈이 복잡해지면 공유자원 사용을 위한 락이 많이 사용되는 경향이 있기 때문에, 스레드(코어)가 많아질수록 CPU 락 경합때문에 발생하는 성능 저하 현상이 문제가 됩니다.
&lt;a href=&quot;https://github.com/openssl/openssl/issues/17627#issuecomment-1060123659&quot;&gt;공식 github사이트에 30배 CPU부하증가, 3배/10배/80배 느려짐, 95% CPU 등&lt;/a&gt; 여러 성능 이슈가 보고되고 있고, 개선되고 있습니다.&lt;/p&gt;

&lt;p&gt;HAProxy나 그밖의 OpenSSL을 사용하는 시스템이 다중 스레드에서 높은 처리성능을 발휘해야한다면 앞으로도 당분간은 openssl-3보다는 openssl-1.1.1을 사용하시는 것을 권해드립니다.&lt;/p&gt;

</description>
        <pubDate>Fri, 03 Feb 2023 20:00:00 +0900</pubDate>
        <link>http://cwyang.github.io/2023/02/03/slow-openssl-3.0.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2023/02/03/slow-openssl-3.0.html</guid>
        
        <category>blog</category>
        
        <category>ssl</category>
        
        <category>openssl</category>
        
        <category>haproxy</category>
        
        
      </item>
    
      <item>
        <title>패스워드 매니저의 위험성과 클라우드 보안</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://blog.lastpass.com/2022/12/notice-of-recent-security-incident/&quot;&gt;2022년 12월 LastPass의 패스워드들이 유출되었습니다.&lt;/a&gt;
LastPass는 클라우드 스토리지에 패스워드들을 저장하고 있었는데
2022년 8월에 유출된 정보를 통해 이번에 패스워드들이 유출되었다고 해요.
패스워드는 &lt;a href=&quot;Password-Based Key Derivation Function 2&quot;&gt;PKBDF2&lt;/a&gt;(https://en.wikipedia.org/wiki/PBKDF2)&lt;sup&gt;&lt;a href=&quot;#footnote1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;로 암호화되어 있었어요. 즉 해시만이 저장되어 있었는데요. 이게 안전하지 않다는 이야기가 많습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/password.jpg&quot; alt=&quot;패스워드 과연 안전한가?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;보안을 위해 40 비트, 64 비트 키는 안전하지 않다. 128 비트 이상을 사용하라는 이야기 들어보셨을텐데요,
일반적인 사용자들의 패스워드는 40 비트 정도의 엔트로피를 가진다고 합니다.
40 비트키는 매우 취약하다는 이야기 많이 들어보셨을거에요.
랜덤하게 만들어도 72 비트 이상가기가 어렵다고 하는데요.
그래서 PBKDF2를 반복(iteration)해서 적용하여 안전한 키를 만듭니다. 반복할 때마다 패스워드가 강화되는 것이고요, 
&lt;del&gt;+9 집행검이&lt;/del&gt; 안전한 키가 나올때까지 계속 강화하는겁니다.&lt;/p&gt;

&lt;p&gt;이번에 키 누출과 함께 나온 이슈가 LastPass가 PBKDF2를 설렁설렁(?) 사용했다는 것입니다.
LastPass의 주장은 PBKDF2를 100,100번 이터레이션한다는 것이지만 &lt;a href=&quot;https://www.reddit.com/r/Lastpass/comments/106p7le/by_default_the_number_of_password_iterations_that/&quot;&gt;그렇지 않다는 주장들을 볼 수 있어요.&lt;/a&gt; 
약한 패스워드에 대해 강화를 몇번 안돌렸으니 결과도 취약해진거고 그것이 유출된 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.trendmicro.com/vinfo/us/security/news/cyber-attacks/2012-linkedin-breach-117-million-emails-and-passwords-stolen-not-6-5m&quot;&gt;2012년에 LinkedIn 에서도 1억개 이상의 암호화된 패스워드가 유출되었었는데,&lt;/a&gt; 그 암호화 방식이 unsalted SHA1 이어서 문제가 된 적도 있었어요. 같은 패스워드면 암호화된 패스워드도 같았고, 암호화 방식도 취약한 SHA1이었으니 말 다한 것이죠.&lt;/p&gt;

&lt;p&gt;클라우드 스토리지에 고객 정보를 저장할때에는 항상 정보가 유출될 수 있다는 생각을 가지고 고객 데이터를 안전하게 관리해야 합니다.
공개 클라우드는 제대로 보안 관리가 되지 않으면 훔쳐가세요~하는 것과 마찬가지니까요.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;개인정보는 암호화하고&lt;/li&gt;
  &lt;li&gt;암호는 일정수준 이상의 보안강도를 유지하며&lt;/li&gt;
  &lt;li&gt;클라우드상의 리소스의 접근권한을 올바르게 관리해야합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;개인으로서는 세상에 절대 안전한 서비스는 없다는 것을 인지하고
(패스워드 매니저가 털리고 그것이 허술하게 관리될 줄이야 누가 알았겠어요)
복잡한 암호를 사용해서 기본적으로 높은 엔트로피를 주는 것이 중요하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a id=&quot;footnote1&quot;&gt;[1]&lt;/a&gt; &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc2898&quot;&gt;RFC2898&lt;/a&gt;에 정의되어있으며, ISO-27001 보안규정을 준수하고 있는, 제대로 사용한다면 안전한 함수입니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 02 Feb 2023 21:30:00 +0900</pubDate>
        <link>http://cwyang.github.io/2023/02/02/security-of-the-password-mangagers.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2023/02/02/security-of-the-password-mangagers.html</guid>
        
        <category>blog</category>
        
        <category>cloud</category>
        
        <category>security</category>
        
        <category>password</category>
        
        <category>pbkdf2</category>
        
        
      </item>
    
      <item>
        <title>API endpoint들의 취약한 TLS 버젼</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/security/tls-1-2-required-for-aws-endpoints/&quot;&gt;내년 6월부터 모든 AWS API에서 TLS1.2 미만을 지원중지한다는 소식&lt;/a&gt;을 접하여, TLS 버젼 이야기 짧게 드립니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/unlocked.jpg&quot; alt=&quot;TLS 1.0, 1.1은 아주 취약해요!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLS 1.2 미만 (SSL*, TLS1.0, TLS1.1)은 그 보안취약점으로 인해 &lt;a href=&quot;https://datatracker.ietf.org/doc/rfc8996/&quot;&gt;IETF가 2021년 3월에 정식으로 관뚜껑에 못질을 하였습니다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;이 때 &lt;a href=&quot;https://aws.amazon.com/ko/blogs/security/tls-1-2-required-for-aws-fips-endpoints/&quot;&gt;AWS는 FIPS 엔드포인트에서 TLS1.2 미만을 지원중지&lt;/a&gt;하였습니다.&lt;/p&gt;

&lt;p&gt;그리고 내년 6월부로 모든 AWS API에서 TLS1.2 미만을 지원중지하는 것입니다.&lt;/p&gt;

&lt;p&gt;AWS에서는 서비스 마이그레이션을 위해 클라우드트레일에서 접속 TLS 버젼을 확인하고 취약한 TLS1.0, 1.1을 사용하면 해당 클라이언트를 업데이트하도록 권장하고 있습니다.&lt;/p&gt;

&lt;p&gt;브라우저벤더들이 (MS, Google, Apple, Mozilla) 2020~2021년에 걸쳐서 해당 버젼 지원을 중지하였기 때문에 TLS1.2 이상으로 통신을 강제하여도 대부분 문제가 없겠으나
레거시/커스텀 소프트웨어가 TLS통신을 할 경우 취약한 버젼으로 연결이 맺어질 수 있어 보안에 문제가 있는 것입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;신규 서비스 TLS 엔드포인트를 만들때에는 TLS1.2 이상으로 지정하도록 해야하고요,
기존 서비스 엔드포인트에 대해서도 취약한 TLS버젼에 어떻게 대처할 지 고민이 필요하겠지요?
구형 앱이나 프로그램에서 AWS 접속을 할 때 문제 없도록 확인도 해 주셔야겠고요.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bin/openssl s_client -connect dynamodb.us-west-2.amazonaws.com:443 -tls1
CONNECTED(00000003)
depth=3 C = US, ST = Arizona, L = Scottsdale, O = &quot;Starfield Technologies, Inc.&quot;, CN = Starfield Services Root Certificate Authority - G2
verify error:num=20:unable to get local issuer certificate
...
중략
...
SSL-Session:
    Protocol  : TLSv1
    Cipher    : ECDHE-RSA-AES128-SHA
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 06 Jul 2022 08:58:00 +0900</pubDate>
        <link>http://cwyang.github.io/2022/07/06/weak_tls_on_api_endpoint.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2022/07/06/weak_tls_on_api_endpoint.html</guid>
        
        <category>blog</category>
        
        <category>ssl</category>
        
        <category>tls</category>
        
        
      </item>
    
      <item>
        <title>비대면 시대의 보안기술 - 보안 서비스 엣지</title>
        <description>&lt;p&gt;오늘은 비대면 시대의 보안기술로 제로트러스트와 함께 이야기 되고 있는 보안 서비스 엣지에 대해서 간단히 소개를 드려볼까 합니다. 자세한 내용은 링크해드리는 &lt;a href=&quot;https://www.itfind.or.kr/WZIN/jugidong/2051/file1834924209108887227-2051(2022.06.22)-23.pdf&quot;&gt;주간기술동향 2051호&lt;/a&gt; 안의 보안 서비스 엣지 소개글에서 읽어보실 수 있어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/sse-unsplash.jpg&quot; alt=&quot;하이브리드 워크 시대의 정보 보안은 어떻게?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자들의 근처에 엣지를 두어 통신경로를 짧게해서 빠른 서비스를 제공하는 것이 CDN이라면, 마찬가지로 사용자들의 근처에 엣지를 두고, 모든 통신을 엣지를 거치게 하면서 엣지에서 사용자 인증 및 인가, 트래픽 검사, 악성코드 다운로드 차단, 정보 유출 방지 등 보안 기능을 수행하도록 하는 것이 SSE (Secure Service Edge)입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/sse1.png&quot; alt=&quot;SSE와 SASE의 구성&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자와 모든 정보자산이 사내망에 있고, 방화벽으로 내부와 외부를 격리하는 그림이 클라우드 시대에는 맞지 않게 되었어요.&lt;/p&gt;

&lt;p&gt;보안을 하려면 검사및 조치를 하는 중앙지점이 필요한데, 사람은 안에도 있고 밖에도 있고요, 업무 자산도 사내망에도 있고 클라우드에도 있고 파편화되기 시작한거에요. 보안 입장에서 보면 혼돈의 카오스죠.&lt;/p&gt;

&lt;p&gt;사내망으로 일단 트래픽을 유도한 다음에 보안을 수행 후 외부 자산 접근시에는 다시 외부로 내보내는 그림도 충분히 생각해 볼 수 있습니다. 하지만 전송경로가 매우 길어지겠죠. 그래서 엣지에서 하면 되겠네 라고 이야기하고 있는 것이에요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/sse3.png&quot; alt=&quot;(좌): 혼돈의 카오스 (우):엣지에서 제로트러스트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2019년 가트너에서 CDN과 같이 네트워크 성능도 빠르게 하고, 보안 기능도 수행하는 SASE (새시, Secure Access Service Edge)라는 모델을 제시하였고요, 2021년에는 네트워크랑 보안이랑 굳이 다 할 필요 있느냐, 보안만 수행하는 엣지도 충분히 가치있다 하면서 SASE에서 Access를 빼버린 SSE(Secure Service Edge) 모델을 클라우드 보안의 필수 기술로 제시했어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/sse2.png&quot; alt=&quot;가트너 클라우드 보안 하이프 사이클&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2022년 가트너는 SSE에 대한 시장 정의, 전망 및 유력 참여자를 기술한 매직 쿼드런트 보고서를 출판하면서
여러 보안 기능을 사용해야만 하는 고객들은 여러 솔루션을 개별적으로 운영하는 것보다는 통합관리를 선호한다고 하였습니다.&lt;/p&gt;

&lt;p&gt;① ZTNA 도입에 있어서 단일 서비스보다는 SSE에 통합된 형태를 선택할 것이고 (2021년 20% → 2025년 70%). ② 2025년 80%의 기관들은 SWG, CASB, ZTNA를 별도 구매하기보 다는 통합된 SSE 서비스를 사용할 것이며 ③ SSE의 기능 중 데이터 보안의 중요도가 증가할 것이라고 하였습니다.(2021년 15%→2026년 50%)&lt;/p&gt;

&lt;p&gt;보안 서비스 엣지의 주요 기술은 누가 뭐래도 제로트러스트에요. 모든 자원에 대해서 제로트러스트 인증/인가를 집행하고, 그와 아울러 다른 보안기술도 적용하자라는 것이죠.&lt;/p&gt;

&lt;p&gt;땅덩이가 넓은 미국이나 글로벌 스케일로 업무환경을 구축하는 경우라면 보안 엣지의 구축이 필요하지만, 인터넷 인프라가 잘 되어 있는 우리나라의 경우 사용자 근처 엣지까지가 아니더라도 클라우드에서 제로트러스트 모델을 그리는 것만으로도 충분한 효과를 가져 올 수 있을 것이라고 생각합니다. &lt;a href=&quot;https://www.whitehouse.gov/briefing-room/presidential-actions/2021/05/12/executive-order-on-improving-the-nations-cybersecurity/#:~:text=Zero%20Trust&quot;&gt;작년 바이든 대통령의 행정명령에 제로트러스트라는 말이 여러번 등장&lt;/a&gt;했잖아요? 공공 클라우드를 10년 앞서간 미국은 이제 클라우드 보안이 굉장히 중요해지게 된 것이고, 그 답은 제로트러스트다라고 대통령이 답을 내놓은 것이지요. 이 흐름을 우리나라도 조금의 시차를 두고 따라갈 것이라는 것이 합리적인 추측이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;저는 요즘 제로트러스트와 보안서비스엣지 기술에 많은 관심을 가지고 있어요.
가끔씩 글을 써보겠습니다. 감사합니다.&lt;/p&gt;

&lt;p&gt;감사합니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 Jun 2022 19:58:00 +0900</pubDate>
        <link>http://cwyang.github.io/2022/06/23/secure-service-edge.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2022/06/23/secure-service-edge.html</guid>
        
        <category>blog</category>
        
        <category>security</category>
        
        <category>보안</category>
        
        <category>보안서비스엣지</category>
        
        <category>SSE</category>
        
        <category>제로트러스트</category>
        
        <category>ZTNA</category>
        
        
      </item>
    
      <item>
        <title>eBPF와 libbpf</title>
        <description>&lt;h2 id=&quot;ebpf&quot;&gt;eBPF&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://cwyang.github.io/assets/images/eBPF.png&quot; alt=&quot;eBPF&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ebpf.io/&quot;&gt;eBPF&lt;/a&gt;는 커널의 여러 부분에서 프로그래밍을 쉽고 안전하게 할 수 있게 해 준다.&lt;/p&gt;

&lt;p&gt;BPF는 버클리 패킷 필터에서 나온 약자이지만 현재의 eBPF (extended BPF)는 패킷 필터라는 개념을 넘어섰고
커널 모드에서 코드를 안전하게 구동시키기 위한 도구로 진화했다. C와 유사한 문법으로 코드를 작성하면
안전 실행 여부를 확인한 후에 적재할 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;eBPF를 꼭 커널 프로그래머들만 사용해야하는가? 꼭 그렇지많은 않다.
커널의 주요 실행 포인트들에서 eBPF를 위한 후킹 포인트를 제공하고 있기 때문에
종래의 top, iostat, vmstat, perf등보다 상세한
시스템 모니터링을 위해 사용할 수 있다. 넷플릭스 SRE팀의 브렌단 그렉이 eBPF를 이용한 여러가지 도구를 만들어 발표한 이후 &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
SRE, 데브옵스 직무로부터 많은 관심을 받고 있다.&lt;/p&gt;

&lt;h2 id=&quot;bcc&quot;&gt;BCC&lt;/h2&gt;
&lt;p&gt;eBPF 프로그래밍을 하기위해서는 &lt;a href=&quot;https://github.com/iovisor/bcc&quot;&gt;BCC (BPF Compiler Collection)&lt;/a&gt;을 사용했었다.
BCC는 eBPF 소스코드를 실행시에 native binary로 바꾸어준다.
이 때  target machine에 CLang과 커널헤더가 필요하다.
eBPF에서 커널과 인터페이스하려면 stable interface가 필요한데 커널은 항상 변하기 때문이다.
그래서 결과적으로 바이너리가 크고, 실행시 로딩타임이 있고, 타겟 머신에 커널 헤더가 있어야한다는 부담이 있다.&lt;/p&gt;

&lt;h2 id=&quot;libbpf&quot;&gt;libbpf&lt;/h2&gt;
&lt;p&gt;최근 커뮤니티에서 인기를 얻는 것이 &lt;a href=&quot;https://github.com/libbpf/libbpf&quot;&gt;libbpf&lt;/a&gt;이다. &lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;
실행시 &lt;a href=&quot;https://www.kernel.org/doc/html/latest/bpf/btf.html#:~:text=1.-,Introduction,info%20for%20source%2Fline%20information.&quot;&gt;BPF Type Format (BTF)&lt;/a&gt;가 필요하기 때문에, 그의 지원을 위하여  커널 컴파일시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CONFIG_DEBUG_INFO_BTF=y&lt;/code&gt;
옵션을 넣어줘야한다.
libbpf는 해당 정보를 이용해서 타겟 호스트의 커널에 맞도로 컴파일된 BPF코드를 수정해서 로딩해준다.&lt;/p&gt;

&lt;p&gt;최근 커널은 자신을 설명하는 BTF를 제공한다.
아래 명령을 수행하면 모든 커널 타입을 포함하는 vmlinux.h가 생성된다.
이것과 libbpf의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bpf_helpers.h&lt;/code&gt;만 가지면 eBPF에서 커널의 웬만한 것은 다 접근할 수 있다.
다만 &lt;a href=&quot;https://lwn.net/Articles/753601/&quot;&gt;USDT support&lt;/a&gt;등과 같이 아직 BCC가 필요한 부분도 남아있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bpftool btf dump file /sys/kernel/btf/vmlinux format c &amp;gt; vmlinux.h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;libbpf-bpf프로그램의-작성순서&quot;&gt;libbpf BPF프로그램의 작성순서&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;vmlinux.h 만들고&lt;/li&gt;
  &lt;li&gt;Clang 10이상의 버젼으로 BPF 프로그램을 컴파일하고&lt;/li&gt;
  &lt;li&gt;컴파일된 오브젝트 파일에서 BPF 스켈리톤을 만들고&lt;/li&gt;
  &lt;li&gt;BPF 스켈리톤헤더를 userspace 코드에 포함하여&lt;/li&gt;
  &lt;li&gt;컴파일한 BPF 오브젝트코드를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Performance-Tools-Addison-Wesley-Professional-Computing/dp/0136554822&quot;&gt;https://www.amazon.com/Performance-Tools-Addison-Wesley-Professional-Computing/dp/0136554822&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/&quot;&gt;https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://nakryiko.com/posts/bpf-portability-and-co-re/&quot;&gt;https://nakryiko.com/posts/bpf-portability-and-co-re/&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html&quot;&gt;https://www.brendangregg.com/blog/2020-11-04/bpf-co-re-btf-libbpf.html&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 11 Mar 2022 09:36:43 +0900</pubDate>
        <link>http://cwyang.github.io/2022/03/11/libxdp.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2022/03/11/libxdp.html</guid>
        
        <category>blog</category>
        
        <category>ebpf</category>
        
        <category>sre</category>
        
        <category>xdp</category>
        
        <category>libbpf</category>
        
        
      </item>
    
      <item>
        <title>크래시 덤프 수집</title>
        <description>&lt;p&gt;만든 프로그램이 장애가 발생하면 한시라도 빨리 그 내용이 개발자에게 전달이 되어야겠으나,&lt;br /&gt;
일터에서 만든 프로그램의 환경은 주로 폐쇄망이어서 결국 전화나 메시지로 전달을 받고 있다.&lt;br /&gt;
프로그램의 버젼과 관련정보, 스택트레이스등을 자동적으로 받을 수 있는 그 날이 언제인가..&lt;/p&gt;

&lt;h1 id=&quot;크래시덤프coredump-확보-방안&quot;&gt;크래시덤프(coredump) 확보 방안&lt;/h1&gt;

&lt;p&gt;아래 내용은 C binary 기준이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ulimit -c unlimted&lt;br /&gt;
로 코어를 생성을 활성화 한 이후 장애가 나면 코어를 보내주거나 해당 기계에 접속해서 gdb를 이용하여 크래시 덤프를 분석한다.&lt;/li&gt;
  &lt;li&gt;libsegfault.so&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whereis libSegFault.so&lt;/code&gt; 하면 gcc toolchain에 동봉된 libsegfault.so의 위치를 알 수 있다.&lt;br /&gt;
프로그램을 실행시킬 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;env SEGFAULT_SIGNALS=&quot;abrt segv&quot; LD_PRELOAD=${LIBSEGV_LOC} ./test&lt;/code&gt; 과 같이 하면 장애가 발생할 경우 stderr로 stack trace가 출력된다. 이를 전달받아 크래시 상황을 분석한다.&lt;/li&gt;
  &lt;li&gt;sentry와 같은 크래시 덤프 수집 서비스를 사용&lt;br /&gt;
&lt;a href=&quot;https://sentry.io/&quot;&gt;https://sentry.io/&lt;/a&gt; 와 같이 크래시 및 성능 분석 서비스를 제공하는 서비스를 이용한다.&lt;br /&gt;
아래와 같이 sdk의 api들을 호출하고 프로그램을 실행하면 장애 발생 내용을 대시보드에서 모아서 볼 수 있고 유료 플랜을 이용하면 slack notification를 받을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;테스트 소스: &lt;a href=&quot;https://github.com/cwyang/my-blog/tree/master/2022-03-crashdump&quot;&gt;https://github.com/cwyang/my-blog/tree/master/2022-03-crashdump&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sentry_options_t *options = sentry_options_new();
    sentry_options_set_release(options, &quot;my-test-project@0.0.1&quot;);
    sentry_options_set_symbolize_stacktraces(options, 1);
    sentry_options_set_environment(options, &quot;development&quot;);
    sentry_options_set_release(options, &quot;test-example-release&quot;);
    sentry_options_add_attachment(options, &quot;./Makefile&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/wYEPf/btruXY7cohH/HXrErpKExKzT7Naq9sFYFk/img.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Mar 2022 16:14:00 +0900</pubDate>
        <link>http://cwyang.github.io/2022/03/04/collecting-crash-dump.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2022/03/04/collecting-crash-dump.html</guid>
        
        <category>blog</category>
        
        <category>diary</category>
        
        <category>tip</category>
        
        <category>crashdump</category>
        
        <category>libsegfault</category>
        
        <category>sentry</category>
        
        
      </item>
    
      <item>
        <title>git submodule</title>
        <description>&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt; project에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child&lt;/code&gt; project를 git submodule로 사용할 때,&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child&lt;/code&gt;의 hash를 바꾼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt;를 체크아웃해도 로컬 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child&lt;/code&gt;는 변하지 않는다.&lt;/p&gt;

&lt;p&gt;이 때에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git submodule init&lt;/code&gt;를 실행하여 로컬의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent&lt;/code&gt;에서 요구하는 버젼으로 업데이트한 후 사용하면 됨.&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Mar 2022 15:54:00 +0900</pubDate>
        <link>http://cwyang.github.io/2022/03/04/git-submodule.html</link>
        <guid isPermaLink="true">http://cwyang.github.io/2022/03/04/git-submodule.html</guid>
        
        <category>blog</category>
        
        <category>diary</category>
        
        <category>tip</category>
        
        <category>git</category>
        
        <category>submodule</category>
        
        
      </item>
    
  </channel>
</rss>
